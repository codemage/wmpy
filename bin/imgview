#!/usr/bin/env python
# -*- coding: utf-8 -*-
# PySide QT4-based image viewer prototype
import logging
import os, os.path
import sys
import threading
import traceback
import weakref

if __name__ == '__main__':
    if os.environ.get('IMGVIEW_DEBUG', '') != '':
        logging.basicConfig(level=logging.DEBUG, stream=sys.stdout,
            format="%(levelname)s %(message)s")
    else:
        logging.basicConfig(level=logging.INFO,
            format="%(levelname)s %(message)s")
    sys.path[0] = os.path.join(sys.path[0], '..')

import wmpy
from wmpy import imgtag, pyside as wmpyside
from wmpy.pyside import qt
_logger, _dbg, _info, _warn = wmpy.get_logging_shortcuts(__name__)

class TagContents(wmpyside.ListBase):
    def __init__(self, db, tag, parent=None, *args, **kw):
        self._db = weakref.proxy(db)
        self._tag = weakref.proxy(tag)
        wmpyside.ListBase.__init__(self, parent, *args, **kw)
        self._tag.image_list.add_weak_listener(self.changed)

    def _reset(self):
        self._items = [img.name for img in self._tag.image_list]

    def _prep(self, value):
        return self._db.getImage(value)

class TagList(wmpyside.ListBase):
    def __init__(self, db, image, parent=None, *args, **kw):
        self._db = weakref.proxy(db)
        self._image = weakref.proxy(image)
        wmpyside.ListBase.__init__(self, parent, *args, **kw)
        self._image.tags.add_weak_listener(self.changed)

    def _reset(self):
        self._items = sorted(self._image.tags)
        if len(self._items) == 0:
            self._items = [{'name': '(none)', 'rowCount': 0}]

    def _prep(self, val):
        if isinstance(val, dict):
            return val
        return self._db.getTag(val)

class QTag(wmpyside.HasProperties, qt.core.Object):
    name, nameChanged = wmpyside.Property(str, lambda self: self.tag.name)
    listPath, listPathChanged = \
        wmpyside.Property(str, lambda self: self.tag.list_path)
    dirty, dirtyChanged = \
        wmpyside.Property(bool, lambda self: self.tag.dirty)
    images, imagesChanged = \
        wmpyside.Property(qt.core.Object, lambda self: self._images)

    def __init__(self, db, tag):
        qt.core.Object.__init__(self)
        self.tag = weakref.proxy(tag)
        self.db = weakref.proxy(db)
        self._images = TagContents(db, tag)

class QTaggedImage(wmpyside.HasProperties, qt.core.Object):
    # we cheat here: changed signals are not actually fired when the underlying
    #                image is modified which could cause problems if we ever
    #                change an image's tags from Python without using toggleTag
    name, nameChanged = wmpyside.Property(str, lambda self: self._name)
    path, pathChanged = wmpyside.Property(str, lambda self: self._path)
    tags, tagsChanged = wmpyside.Property('QVariant', lambda self: self._tags)
    size, sizeChanged = wmpyside.SimpleProperty(qt.core.Size, "_size")
    url, urlChanged = wmpyside.Property(qt.core.Url, lambda self:
        qt.core.Url.fromLocalFile(self._path))

    def __init__(self, db, taggedImage):
        qt.core.Object.__init__(self)
        self._image = weakref.proxy(taggedImage, self.clear)
        self._name = self._image.name
        self._path = self._image.path
        self._db = weakref.proxy(db)
        self._tags = TagList(db, taggedImage)
        self._size = qt.core.Size(0, 0)
        
    def clear(self, _ref=None):
        self._name = ''
        self.nameChanged.emit()
        self._path = 'nothing_loaded.png'
        self.pathChanged.emit()
        self.urlChanged.emit()
        self._tags = None
        self.tagsChanged.emit()
        self.size = qt.core.Size(0,0)

    @qt.core.Slot(str)
    def toggleTag(self, name):
        if name in self._image.tags:
            print("removing tag %s from %s" % (name, self.name))
            self._image.tags.remove(name)
        else:
            print("adding tag %s to %s" % (name, self.name))
            self._image.tags.append(name)
        self.tagsChanged.emit()

class QTagDB(wmpy.InstanceLoggingMixin,
             wmpyside.HasProperties,
             qt.core.Object):
    loading, loadingChanged = wmpyside.SimpleProperty(bool, '_loading')
    loaded, loadedChanged = wmpyside.SimpleProperty(bool, '_loaded')
    failed, failedChanged = wmpyside.SimpleProperty(str, '_failed')
    tags, tagsChanged = wmpyside.SimpleProperty('QVariantMap', '_tags')
    startingTagExpr, startingTagExprChanged = wmpyside.SimpleProperty(str, '_startingTagExpr')

    def __init__(self, startingTagExpr, *args, **kw):
        qt.core.Object.__init__(self, *args, **kw)
        self.startingTagExpr = startingTagExpr
        self._db = None
        self.close()

    def save(self):
        if self.loaded:
            self._db.save_dirty()

    def _resetTags(self):
        if self._db is None:
            self.tags = {}
        else:
            self.tags = {tag.name: QTag(self, tag)
                for tag in list(self._db.tags.values())}

    @qt.core.Slot(str)
    def open(self, config_path):
        if self._loading:
            raise ValueError("already loading")
        if self._loaded:
            self.clear()

        self.loading = True
        self._db = imgtag.TagDB(config_path)
        def _load(self=self):
            try:
                completed = self._db.scan()
                if not completed:
                    self._db = None
            except:
                self._warn('failed to load', exc_info=True)
                self.failed = str(sys.exc_info()[1])
                self._db = None
            self._resetTags()
            self.loaded = (self._db is not None)
            self.loading = False
        thread = threading.Thread(target=_load)
        thread.daemon = True
        thread.start()

    @qt.core.Slot()
    def close(self):
        if self._db is not None and self.loading:
            self._db.stopScan()
        self._db = None
        self.loading = False
        self.loaded = False
        self.failed = ''
        self.tags = {}
        self.tagNames = []
        if hasattr(self, '_qimages'):
            for image in self._qimages.values():
                image.clear()
        self._qimages = {}

    scan = qt.core.Slot()(imgtag.TagDB.scan)
    save_dirty = qt.core.Slot()(imgtag.TagDB.save_dirty)

    @qt.core.Slot(str, result=bool)
    def hasTag(self, name):
        return self.loaded and name in self._db.tags
    
    @qt.core.Slot(str, result="QVariant") # QTag or None
    def getTag(self, name):
        if not self.loaded:
            _warn("call to getTag when tagdb not loaded")
            return None
        if name not in self._db.tags:
            self._db._tag(name)
            self._resetTags()
        return self._tags[name]

    @qt.core.Slot(str, result="QVariant") # QTaggedImage or None
    def getImage(self, name):
        if not self.loaded:
            _warn("call to getImage when tagdb not loaded")
            return None
        if name not in self._db.images:
            return None
        if name not in self._qimages:
            image = self._db.images[name]
            self._qimages[name] = QTaggedImage(self, image)
        #self._dbg("returning qimage %s@%s", name, id(self._qimages[name]))
        return self._qimages[name]

    @qt.core.Slot(str, result="QVariant")
    def getImageList(self, tagexpr):
        print("getImageList", repr(tagexpr))
        imagelist = wmpyside.ListModel()
        if not self.loaded:
            return imagelist
        if tagexpr in self._db.tags:
            imagenames = self.getTag(tagexpr).images[:]
            imagelist[:] = (self.getImage(name) for name in imagenames)
        else:
            try:
                images = self._db.find_by_tags(tagexpr)
                imagelist[:] = (self.getImage(i.name) for i in images)
            except Exception:
                _warn("error in tagexpr", exc_info=True)
                traceback.print_exc()
        return imagelist

class ViewProxy(qt.core.Object):
    def __init__(self, view):
        super(ViewProxy, self).__init__()
        self._view = weakref.ref(view)

    @qt.core.Slot(result="QVariant")
    def getView(self):
        return self._view()

class ImgView(qt.quick.View):
    qml_path = os.path.join(os.path.dirname(__file__), '..', 'qml')

    def __init__(self, tags_dir, starting_tagexpr, *args, **kw):
        qt.quick.View.__init__(self, *args, **kw)
        self.config_path = config_path=os.path.join(tags_dir, 'imgtag.cfg')
        self.db = QTagDB(starting_tagexpr)
        self.rootContext().setContextProperty('tagdb', self.db)
        self.rootContext().setContextProperty('viewProxy', ViewProxy(self))
        self._closed = False

        self.initialized = False
        self.statusChanged.connect(self.statusCheck)
        self.setSource(qt.core.Url.fromLocalFile(
            os.path.join(self.qml_path, 'imgview.qml')))

    def statusCheck(self):
        if self.status() == qt.quick.View.Error:
            # TODO: consider popping up an error message, use self.errors
            # may need to listen to self.engine.warnings and self.engine.setOutputWarningsToStandardError(False)
            sys.stderr.write("Failed to load QML\n")
            self.close()
            qt.core.CoreApplication.exit(1)
            sys.exit(1)
        elif self.initialized or self.status() == qt.quick.View.Loading:
            return

        try:
            assert self.status() == qt.quick.View.Ready

            self.setWindowTitle("ImgView")
            self.setResizeMode(qt.quick.View.SizeRootObjectToView)
            self.engine().quit.connect(self.close)

            self.db.open(self.config_path)
        except:
            _warn("error loading", exc_info=True)
            self.close()
            qt.core.CoreApplication.exit(1)
            sys.exit(1)

        self.initialized = True
        self.show()

    def closeEvent(self, evt):
        self.db.save()
        self.db.close()
        qt.core.CoreApplication.quit()

gen_parser = wmpy.ParserGenerator()

@gen_parser()
def main(tags_dir='.', starting_tagexpr='untagged'):
    view = ImgView(tags_dir, starting_tagexpr)
    try:
        return qt.core.CoreApplication.exec_()
    finally:
        view.destroy()

if __name__ == '__main__':
    app = qt.gui.Application(sys.argv)
    qt_argv = app.arguments()
    if 'python' in qt_argv[0]:
        del qt_argv[0]
    del qt_argv[0]
    sys.exit(main.parse_and_call(qt_argv))
