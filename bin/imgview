#!/usr/bin/env python
# -*- coding: utf-8 -*-
# PySide QT4-based image viewer prototype
import collections
import logging
import os, os.path
import sys
import time
import threading
import traceback
import weakref

if __name__ == '__main__':
    if os.environ.get('IMGVIEW_DEBUG', '') != '':
        logging.basicConfig(level=logging.DEBUG, stream=sys.stdout,
            format="%(levelname)s %(message)s")
    else:
        logging.basicConfig(level=logging.INFO,
            format="%(levelname)s %(message)s")
    sys.path[0] = os.path.join(sys.path[0], '..')

import wmpy
from wmpy import imgtag, pyside as wmpyside
from wmpy.pyside import qt
_logger, _dbg, _info, _warn = wmpy.get_logging_shortcuts(__name__)

class TagContents(wmpyside.ListBase):
    def __init__(self, db, tag, parent=None, *args, **kw):
        self._db = weakref.proxy(db)
        self._tag = weakref.proxy(tag)
        wmpyside.ListBase.__init__(self, parent, *args, **kw)
        self._tag.image_list.add_weak_listener(self.changed)

    def _reset(self):
        self._items = [img.name for img in self._tag.image_list]

    def _prep(self, value):
        return self._db.getImage(value)

class QTag(wmpyside.HasProperties, qt.core.Object):
    name, nameChanged = wmpyside.Property(str, lambda self: self.tag.name)
    listPath, listPathChanged = \
        wmpyside.Property(str, lambda self: self.tag.list_path)
    dirty, dirtyChanged = \
        wmpyside.Property(bool, lambda self: self.tag.dirty)
    images, imagesChanged = \
        wmpyside.Property(qt.core.Object, lambda self: self._images)

    def __init__(self, db, tag):
        qt.core.Object.__init__(self)
        self.tag = weakref.proxy(tag)
        self.db = weakref.proxy(db)
        self._images = TagContents(db, tag)

class QTaggedImage(wmpyside.HasProperties, qt.core.Object):
    # we cheat here: changed signals are not actually fired when the underlying
    #                image is modified which could cause problems if we ever
    #                change an image's tags from Python without using toggleTag
    name, nameChanged = wmpyside.SimpleProperty(str, '_name')
    path, pathChanged = wmpyside.SimpleProperty(str, '_path')
    tags, tagsChanged = wmpyside.SimpleProperty('QVariant', '_tags')
    size, sizeChanged = wmpyside.SimpleProperty(qt.core.Size, "_size")
    url, urlChanged = wmpyside.Property('QVariant', lambda self:
        qt.core.Url.fromLocalFile(self._path) if self._path else "")

    def __init__(self, db, taggedImage):
        qt.core.Object.__init__(self)
        self._image = weakref.proxy(taggedImage, self.clear)
        self._name = self._image.name
        self._path = self._image.path
        self._tags = list(taggedImage.tags)
        self._size = qt.core.Size(0, 0)
        
    def clear(self, _ref=None):
        del self._image
        self.name = ''
        self.path = ''
        self.urlChanged.emit()
        self.tags = []
        self.size = qt.core.Size(0,0)

    @qt.core.Slot(str)
    def toggleTag(self, name):
        if not hasattr(self, '_image'):
            _dbg('bad call to cleared image toggleTag')
            return
        if name in self._image.tags:
            print("removing tag %s from %s" % (name, self.name))
            self._image.tags.remove(name)
        else:
            print("adding tag %s to %s" % (name, self.name))
            self._image.tags.append(name)
        self.tags = list(self._image.tags)

class QTagDB(wmpy.InstanceLoggingMixin,
             wmpyside.HasProperties,
             qt.core.Object):
    loading, loadingChanged = wmpyside.SimpleProperty(bool, '_loading')
    loaded, loadedChanged = wmpyside.SimpleProperty(bool, '_loaded')
    failed, failedChanged = wmpyside.SimpleProperty(str, '_failed')
    tags, tagsChanged = wmpyside.SimpleProperty('QVariantMap', '_tags')
    startingTagExpr, startingTagExprChanged = wmpyside.SimpleProperty(str, '_startingTagExpr')

    def __init__(self, startingTagExpr, *args, **kw):
        qt.core.Object.__init__(self, *args, **kw)
        self.startingTagExpr = startingTagExpr
        self._db = None
        self._qimages = {}
        self.close()

    def save(self):
        if self.loaded:
            self._db.save_dirty()

    def _resetTags(self):
        if self._db is None:
            self.tags = {}
        else:
            self.tags = {tag.name: QTag(self, tag)
                for tag in list(self._db.tags.values())}

    @qt.core.Slot(str)
    def open(self, config_path):
        if self._loading:
            raise ValueError("already loading")
        if self._loaded:
            self.clear()

        self.loading = True
        self._db = imgtag.TagDB(config_path)
        def _load(self=self):
            try:
                completed = self._db.scan()
                if not completed:
                    self._db = None
            except:
                self._warn('failed to load', exc_info=True)
                self.failed = str(sys.exc_info()[1])
                self._db = None
            self._resetTags()
            self.loaded = (self._db is not None)
            self.loading = False
        thread = threading.Thread(target=_load)
        thread.daemon = True
        thread.start()

    @qt.core.Slot()
    def close(self):
        if self._db is not None and self.loading:
            self._db.stopScan()
        self._db = None
        self.loading = False
        self.loaded = False
        self.failed = ''
        self.tags = {}
        self.tagNames = []
        for image in self._qimages.values():
            image.clear()
        self._qimages = {}

    scan = qt.core.Slot()(imgtag.TagDB.scan)
    save_dirty = qt.core.Slot()(imgtag.TagDB.save_dirty)

    @qt.core.Slot(str, result=bool)
    def hasTag(self, name):
        return self.loaded and name in self._db.tags
    
    @qt.core.Slot(str, result="QVariant") # QTag or None
    def getTag(self, name):
        if not self.loaded:
            _warn("call to getTag when tagdb not loaded")
            return None
        if name not in self._db.tags:
            self._db._tag(name)
            self._resetTags()
        return self._tags[name]

    @qt.core.Slot(str, result="QVariant") # QTaggedImage or None
    def getImage(self, name):
        if not self.loaded:
            _warn("call to getImage when tagdb not loaded")
            return None
        if name not in self._db.images:
            return None
        if name not in self._qimages:
            image = self._db.images[name]
            self._qimages[name] = QTaggedImage(self, image)
        #self._dbg("returning qimage %s@%s", name, id(self._qimages[name]))
        return self._qimages[name]

    @qt.core.Slot(str, result="QVariant")
    def getImageList(self, tagexpr):
        _dbg("getImageList %s", repr(tagexpr))
        imagelist = wmpyside.ListModel()
        if not self.loaded:
            return imagelist
        try:
            images = self._db.find_by_tags(tagexpr)
            imagelist[:] = (self.getImage(i.name) for i in images)
        except Exception:
            _warn("error in tagexpr", exc_info=True)
            traceback.print_exc()
        return imagelist

class ViewProxy(qt.core.Object):
    def __init__(self, view):
        super(ViewProxy, self).__init__()
        self._view = weakref.ref(view)

    @qt.core.Slot(result="QVariant")
    def getView(self):
        return self._view()

class Context(object):
    def __init__(self, view):
        self._wrapped = view.rootContext()
    def __getattr__(self, name):
        return self._wrapped.contextProperty(name)
    def __setattr__(self, name, value):
        if name != '_wrapped':
            self._wrapped.setContextProperty(name, value)
        super.__setattr__(self, name, value)

class ImgViewWidget(qt.quick.View):
    @property
    def root(self):
        return self.rootObject()

    @property
    def ctx(self):
        return Context(self)

    def hideEvent(self, event):
        if self.isVisible():
            return qt.quick.View.hideEvent(self, event)
        _dbg("hide event recieved, closing")
        # getattr(self.root.property('images'), 'clear', lambda:None)()
        
        self.ctx.tagdb.save()
        self.ctx.tagdb.close()
        return qt.quick.View.hideEvent(self, event)

class ImgView(object):
    qml_path = os.path.join(os.path.dirname(__file__), '..', 'qml')

    def __init__(self, tags_dir, starting_tagexpr, *args, **kw):
        self.initialized = False
        self.view = ImgViewWidget(*args, **kw)
        self.config_path = config_path=os.path.join(tags_dir, 'imgtag.cfg')
        self.view.ctx.tagdb = QTagDB(starting_tagexpr)
        self.view.ctx.viewProxy = ViewProxy(self.view)

        self.view.statusChanged.connect(self.statusCheck)
        self.view.setSource(qt.core.Url.fromLocalFile(
            os.path.join(self.qml_path, 'imgview.qml')))

    def _abort(self):
        if self.view.isVisible():
            self.view.close()
        else:
            _dbg("error, aborting")
            self.view.destroy()
            qt.gui.Application.exit(1)
            sys.exit(1)

    def statusCheck(self):
        if self.view.status() == qt.quick.View.Error:
            # TODO: consider popping up an error message, use self.errors
            # may need to listen to self.engine.warnings and self.engine.setOutputWarningsToStandardError(False)
            errors = '\n'.join(str(err) for err in self.view.errors())
            qt.gui.MessageBox.critical(None, 'Error Loading ImgView', 'Failed to load QML:\n' + errors)
            _logger.critical("Failed to load QML")
            return self._abort()
        elif self.initialized or self.view.status() == qt.quick.View.Loading:
            return

        try:
            assert self.view.status() == qt.quick.View.Ready

            self.view.setWindowTitle("ImgView")
            self.view.setResizeMode(qt.quick.View.SizeRootObjectToView)
            self.view.engine().quit.connect(self.view.close)
            self.view.ctx.tagdb.open(self.config_path)
        except:
            _logger.critical("error loading", exc_info=True)
            qt.gui.MessageBox.critical(None, 'Error Loading ImgView', 'Exception while loading:\n' + traceback.format_exc())
            return self._abort()

        self.initialized = True
        self.view.show()

gen_parser = wmpy.ParserGenerator()

@gen_parser()
def main(tags_dir='.', starting_tagexpr='untagged'):
    controller = ImgView(tags_dir, starting_tagexpr)
    return qt.gui.Application.exec_()

if __name__ == '__main__':
    app = qt.gui.Application(sys.argv)
    qt_argv = app.arguments()
    if 'python' in qt_argv[0]:
        del qt_argv[0]
    del qt_argv[0]
    sys.exit(main.parse_and_call(qt_argv))
