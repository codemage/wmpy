#!/usr/bin/env python

"""
This is a tool for doing image or photo tagging by integrating with the feh
image viewer for Linux.  The storage format is a Python configuration file
plus a list of plain text ".list" files with relative paths to images, and
it makes the presumption that image filenames are unique within the directory
tree on which it operates.

It is portable and can interact with the tagset on Windows, but is only really
useful on operating systems with Unix-style shells and pipe semantics because the
'view' action relies heavily on feh and on some magic with Unix FIFO descriptors.

This is software built for personal use; if anyone besides me can figure out how
to make it work, great, but for now I am not going to bother documenting it properly.
"""

import errno
import logging
import os
import os.path
import re
import shlex
import sys

if __name__ == '__main__':
    if os.environ.get('IMGTAG_DEBUG', '') != '':
        logging.basicConfig(level=logging.DEBUG, stream=sys.stdout,
            format="%(levelname)s %(message)s")
    else:
        logging.basicConfig(level=logging.INFO,
            format="%(levelname)s %(message)s")
    sys.path[0] = os.path.join(sys.path[0], '..')

import wmpy
from wmpy.imgtag import TagDB
_logger, _dbg, _info, _warn = wmpy.get_logging_shortcuts(__name__)

def parse_bindings(db, bindings):
    binding_pairs = [ b.split('=') for b in bindings ]
    return { name: set(value.split(',')) if value else set()
        for name, value in binding_pairs }

gen_parser = wmpy.ParserGenerator(ignored_args=['db'], 
    tagexpr=dict(help='image selection expression',
        metavar='"<tagexpr>"', nargs='?'),
    bindings=dict(help='tagsets to bind in expr',
        metavar='name=tag[,...]', nargs='*'),
    )

@gen_parser(
    feh=dict(short='f', help='arguments to viewer',
             metavar='<feh args>', action='append'),
    )
def do_view(db, tagexpr='True', feh=('-Z', '-F'), *bindings):
    """View/tag images in feh, selected based on their tags"""
    try:
        bindings = parse_bindings(db, bindings)
        feh_args = shlex.split(' '.join(feh))
        db.view_tags(tagexpr, feh_args=feh_args, **bindings)
    finally:
        def _save():
            # add stack frame so as not to modify exception context
            try:
                db.save_dirty()
            except Exception:
                pass
        _save()

@gen_parser(
    dupes=dict(short='d', action='store_true',
               help='only show duplicated images'),
    long=dict(short='l', action='store_true',
               help='list by name, with tags and path'),
    )
def do_ls(db, tagexpr='True', dupes=False, long=False, *bindings):
    """List information about images, selected based on their tags"""
    bindings = parse_bindings(db, bindings)
    try:
        for image in sorted(db.find_by_tags(tagexpr, **bindings)):
            if dupes and len(image.paths) == 1:
                continue
            if long:
                duplicates = [' + %s' % d for d in image.paths if d != image.path]
                dupe_str = ''.join(duplicates)
                print "%s\t|%s|\t%s%s" % (image.name, image.tagstr, image.path, dupe_str)
            else:
                print os.path.relpath(image.path)
    except IOError, ioerr:
        if ioerr.errno != errno.EPIPE: # if EPIPE, don't care
            raise

@gen_parser
def do_tag(db):
    """Read lines like <add/remove> <filename> <tag> from stdin."""
    for line in sys.stdin:
        if line.strip() == '':
            continue
        cmd, name, tag = line.strip().split()
        if cmd == 'add':
            db.images[name].tags.append(tag)
        elif cmd == 'remove':
            db.images[name].tags.remove(tag)
        else:
            raise ValueError('unknown command: ' + line.strip())
    db.save_dirty()

@gen_parser
def do_debug(db):
    import code
    code.interact(local=dict(db=db))

actions = {name[3:].replace('_', '-'): func
    for name, func in globals().iteritems()
    if name.startswith('do_') and hasattr(func, 'parser')}

@gen_parser(
    parser_args=dict(add_help=False, prog=sys.argv[0]),
    ignore=['argv'],
    cfg=dict(short='c', help='config file to use', metavar='<imgtag.cfg>'),
    action=dict(nargs='?', choices=actions.keys()),
    help=dict(short='h', action='store_true',
              help='show this help message and exit')
    )
def main(cfg='imgtag.cfg', action=None, help=False, argv=[]):
    if help:
        if action is not None:
            actions[options.action].parser.print_help()
        else:
            # don't set metavar in params, the default {a|b|c}
            # is good for print_usage(); this is better for long help:
            main.args['action'].metavar = '<action>'
            main.parser.print_help()
            print "\n<action> may be any of:"
            for name, action in actions.iteritems():
                print "  %s: %s" % (name, action.__doc__)
                usage = action.parser.format_usage()
                usage = usage.replace(' %s' % sys.argv[0], '')
                usage = re.sub('\n +', " ", usage).replace(' [-h]', '')
                print "     ", usage,
        print
        return 0
    elif action is None:
        main.parser.print_usage()
        return 1
        
    action = actions[options.action]
    action_kw = {}
    if 'db' in action.required_args:
        action_kw['db'] = TagDB(config_path=cfg)
        action_kw['db'].scan()
    return action.parse_and_call(argv, **action_kw)

if __name__ == '__main__':
    options, extra_argv = main.parser.parse_known_args(sys.argv[1:])
    options.argv = extra_argv
    sys.exit(main.call_with_options(**vars(options)))

