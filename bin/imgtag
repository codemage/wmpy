#!/usr/bin/env python

"""
This is a tool for doing image or photo tagging by integrating with the feh
image viewer for Linux.  The storage format is a Python configuration file
plus a list of plain text ".list" files with relative paths to images, and
it makes the presumption that image filenames are unique within the directory
tree on which it operates.

It is portable and can interact with the tagset on Windows, but is only really
useful on operating systems with Unix-style shells and pipe semantics because the
'view' action relies heavily on feh and on some magic with Unix FIFO descriptors.

This is software built for personal use; if anyone besides me can figure out how
to make it work, great, but for now I am not going to bother documenting it properly.
"""

import errno
import itertools
import logging
import os
import os.path
import re
import shlex
import sys

if __name__ == '__main__':
    if os.environ.get('IMGTAG_DEBUG', '') != '':
        logging.basicConfig(level=logging.DEBUG, stream=sys.stdout,
            format="%(levelname)s %(message)s")
    else:
        logging.basicConfig(level=logging.INFO,
            format="%(levelname)s %(message)s")
    sys.path[0] = os.path.join(sys.path[0], '..')

import wmpy
from wmpy.imgtag import TagDB
_logger, _dbg, _info, _warn = wmpy.get_logging_shortcuts(__name__)

def parse_bindings(db, bindings):
    binding_pairs = [ b.split('=') for b in bindings ]
    return { name: set(value.split(',')) if value else set()
        for name, value in binding_pairs }

gen_parser = wmpy.ParserGenerator(ignored_args=['db'], 
    tagexpr=dict(help='image selection expression',
        metavar='"<tagexpr>"', nargs='?'),
    bindings=dict(help='tagsets to bind in expr',
        metavar='name=tag[,...]', nargs='*'),
    )

def view_tags(db, tagexpr, feh_args=(), **bindings):
    paths = db.images_to_paths(
                db.find_by_tags(tagexpr, **bindings))

    if len(paths) == 0:
        print("No matching images.\n")
        return

    with _io.Pipe() as (cmd_r, cmd_w), \
         _io.Pipe() as (info_r, info_w):

        def _preexec():
            os.close(cmd_r.fileno())
            os.close(info_w.fileno())

        tag_bindings = db.config.get('tag_bindings', {})
        cmd = ['feh', '--info',  # remainder is info cmd def:
            'IFS="";'
            'exec <&%s;'
            'echo info "%%f" >&%d;'
            'read -r INFO;'
            'echo "$INFO"' % (info_r.fileno(), cmd_w.fileno())]
        for numkey, tag in tag_bindings.items():
            cmd.extend(('--action%d' % numkey,
                ';echo tag %s "%%f" >&%d' % (tag, cmd_w.fileno())))
        cmd.extend(feh_args)
        paths_on_stdin = True
        if paths_on_stdin:
            cmd.extend(['-f', '-'])
            _info('Running viewer: %s < [%d paths]',
                ' '.join(map(pipes.quote, cmd)), len(paths))
        else:
            _info('Running viewer: %s [%d paths]',
                ' '.join(map(pipes.quote, cmd)), len(paths))
            cmd.extend(paths)

        viewer = sp.Popen(cmd, stdin=sp.PIPE, preexec_fn=_preexec,
            cwd=db.top_path)
        cmd_w.close()
        info_r.close()

        finish_cond = threading.Condition()
        thread_err = []
        def _notify_finish():
            with finish_cond:
                if sys.exc_info() != (None, None, None):
                    thread_err[:] = sys.exc_info()
                finish_cond.notify_all()

        def _comm_thread_func():
            if paths_on_stdin:
                input_data = '\n'.join(paths)
            else:
                input_data = ''
            viewer.communicate(input=input_data)
            _notify_finish()

        binding_desc = ' '.join(
            '%s->%s' % (k,v)
            for k,v in list(tag_bindings.items()))
        def _cmd_info(command):
            fn = ' '.join(command[1:])
            _dbg("info request: %s", fn)
            image = db.images[p.basename(fn)]
            info_w.write('%s tags=|%s|\\n%s\n' %
                (image, image.tagstr, binding_desc))
            info_w.flush()

        def _cmd_tag(command):
            tag = db._tag(command[1])
            fn = ' '.join(command[2:])
            image = db.images[p.basename(fn)]
            if tag.name in image.tags:
                _warn("remove tag %s %s", image, tag)
                tag.image_list.remove(image)
            else:
                _warn("add tag %s %s", image, tag)
                tag.image_list.append(image)

        def _cmd_thread_func():
            _dbg('viewer command thread starting')
            for cmdline in cmd_r:
                command = cmdline.strip().split(' ')
                if command[0] == 'info':
                    _cmd_info(command)
                elif command[0] == 'tag':
                    _cmd_tag(command)
                else:
                    _warn("unknown command from viewer: %r" % cmdline)
            _notify_finish()
    
        try:
            comm_thread = _threading.WatchedThread('comm_thread',
                _comm_thread_func, _notify_finish)
            comm_thread.start()
            cmd_thread = _threading.WatchedThread('cmd_thread',
                _cmd_thread_func, _notify_finish)
            cmd_thread.start()
            _threading.WatchedThread.join_all(comm_thread, cmd_thread)
        finally:
            if viewer.returncode is None:
                os.kill(viewer.pid, 15) # TERM

    if viewer.returncode != 0:
        sys.exit(viewer.returncode)

@gen_parser(
    feh=dict(short='f', help='arguments to viewer',
             metavar='<feh args>', action='append'),
    )
def do_view(db, tagexpr='True', feh=('-Z', '-F'), *bindings):
    """View/tag images in feh, selected based on their tags"""
    try:
        bindings = parse_bindings(db, bindings)
        feh_args = shlex.split(' '.join(feh))
        view_tags(tagexpr, feh_args=feh_args, **bindings)
    finally:
        def _save():
            # add stack frame so as not to modify exception context
            try:
                db.save_dirty()
            except Exception:
                pass
        _save()

@gen_parser
def do_dupes(db):
    for entry in db.find_dupes():
        images = set(entry.values())
        if len(images) > 1:
            for image in images:
                print(list(image.tags), ascii(image.name))
            print("-----------------------------")

@gen_parser(
    dupes=dict(short='d', action='store_true',
               help='only show duplicated images'),
    long=dict(short='l', action='store_true',
               help='list by name, with tags and path'),
    )
def do_ls(db, tagexpr='True', dupes=False, long=False, *bindings):
    """List information about images, selected based on their tags"""
    bindings = parse_bindings(db, bindings)
    try:
        for image in sorted(db.find_by_tags(tagexpr, **bindings)):
            if dupes and len(image.paths) == 1:
                continue
            if int:
                duplicates = [' + %s' % d for d in image.paths if d != image.path]
                dupe_str = ''.join(duplicates)
                print("%s\t|%s|\t%s%s" % (image.name, image.tagstr, image.path, dupe_str))
            else:
                print(os.path.relpath(image.path))
    except IOError as ioerr:
        if ioerr.errno != errno.EPIPE: # if EPIPE, don't care
            raise

@gen_parser
def do_tag(db):
    """Read lines like <add/remove> <filename> <tag> from stdin."""
    for line in sys.stdin:
        if line.strip() == '':
            continue
        cmd, name, tag = line.strip().split()
        if cmd == 'add':
            db.images[name].tags.append(tag)
        elif cmd == 'remove':
            db.images[name].tags.remove(tag)
        else:
            raise ValueError('unknown command: ' + line.strip())
    db.save_dirty()

@gen_parser
def do_debug(db):
    import code
    code.interact(local=dict(db=db))

actions = {name[3:].replace('_', '-'): func
    for name, func in globals().items()
    if name.startswith('do_') and hasattr(func, 'parser')}

@gen_parser(
    parser_args=dict(add_help=False, prog=sys.argv[0]),
    ignore=['argv'],
    cfg=dict(short='c', help='config file to use', metavar='<imgtag.cfg>'),
    action=dict(nargs='?', choices=list(actions.keys())),
    help=dict(short='h', action='store_true',
              help='show this help message and exit')
    )
def main(cfg='imgtag.cfg', action=None, help=False, argv=[]):
    if help:
        if action is not None:
            actions[options.action].parser.print_help()
        else:
            # don't set metavar in params, the default {a|b|c}
            # is good for print_usage(); this is better for long help:
            main.args['action'].metavar = '<action>'
            main.parser.print_help()
            print("\n<action> may be any of:")
            for name, action in actions.items():
                print("  %s: %s" % (name, action.__doc__))
                usage = action.parser.format_usage()
                usage = usage.replace(' %s' % sys.argv[0], '')
                usage = re.sub('\n +', " ", usage).replace(' [-h]', '')
                print("     ", usage, end=' ')
        print()
        return 0
    elif action is None:
        main.parser.print_usage()
        return 1
        
    action = actions[options.action]
    action_kw = {}
    if 'db' in action.required_args:
        action_kw['db'] = TagDB(config_path=cfg)
        action_kw['db'].scan()
    return action.parse_and_call(argv, **action_kw)

if __name__ == '__main__':
    options, extra_argv = main.parser.parse_known_args(sys.argv[1:])
    options.argv = extra_argv
    sys.exit(main.call_with_options(**vars(options)))

